import java.io.*;
import java.util.Scanner;

public class Simulation {
    public static void main(String[] args) throws IOException {

        /* Variables*/
        Scanner inScanner = null;
        PrintWriter report = null;
        PrintWriter trace = null;
        Queue backup = new Queue();
        Queue storage = new Queue();
        Queue[] processorQueues = null;
        int[] prevFinishTime = null;
        int m = 0;
        int time = 0;
        int finishedJobs = 0;
        int jobIndex = 0;

        try { /* Check command line arguments*/
            if (args.length != 1) {
                System.out.println("Usage: Simultation infile");
                System.exit(1);
            }

            /* Input*/
            inScanner = new Scanner(new File(args[0]));
            report = new PrintWriter(new FileWriter(args[0] + ".rpt"));
            trace = new PrintWriter(new FileWriter(args[0] + ".trc"));
        } catch(FileNotFoundException e) {
            System.out.println("Caught Exception " + e);
            System.exit(1);
        }

        m = inScanner.nextInt();
        String getLine = inScanner.nextLine();
        while(inScanner.hasNext()) 
        {
            Job job = getJob(inScanner);
            backup.enqueue(job);
        }

        /* Trace and Report*/
        trace.println("Trace file: " + (args[0] + ".trc"));
        trace.println(m + " Jobs:");
        trace.println(backup.toString());
        trace.println();

        report.println("Report file: " + (args[0] + ".rpt"));
        report.println(m + " Jobs:");
        report.println(backup.toString());
        report.println();
        report.println("***********************************************************");

        for (int n = 1; n < m - 1; n++) 
        {
            int totalWait = 0;
            int maxWait = 0;
            double avgWait = 0.0;

            for(int i = 0; i < backup.length(); i++) 
            {
                Job job = (Job) backup.dequeue();
                job.resetFinishTime();
                storage.enqueue(job);
                backup.enqueue(job);
            }

            int processors = n;
            processorQueues = new Queue[n + 1];
            prevFinishTime = new int[n];
            processorQueues[0] = storage;
            for(int i = 1; i < n+1; i++) 
            {
                processorQueues[i] = new Queue();
            }

            trace.println("*****************************");
            if(processors == 1)
                trace.println(processors + " processor:");
            else
                trace.println(processors + " processors:");
            trace.println("*****************************");

            trace.println("time=" + time);
            trace.println("0: " + storage.toString());
            for (int i = 1; i < processors+1; i++) 
            {
                trace.println(i + ": " + processorQueues[i]);
            }

            while (finishedJobs != m) 
            {
                int gArrival = Integer.MAX_VALUE;
                int finalIndex = 1;
                int gFinish = -1;
                int length = -1;
                int finalLength = -1;
                Job allJobs = null;

                /* Checks storage arrival time*/
                if (!storage.isEmpty()) 
                {
                    Job job  = (Job)storage.peek();
                    if (time >= job.getArrival())
                    {
                        if (jobIndex == 0)
                        {
                            Job temp = (Job) storage.dequeue();
                            temp.computeFinishTime(time);
                        }
                    }
                    gArrival = job.getArrival();
                    finalIndex = 0;
                }

                for(int i = 1; i < processors+1; i++) 
                {
                    if (processorQueues[i].length() != 0) 
                    {
                        allJobs = (Job)processorQueues[i].peek();
                        gFinish = allJobs.getFinish();
                    }
                    if (gFinish == -1) 
                    {
                        /* Do Nothing?*/
                    } 
                    else if (gFinish < gArrival) 
                    {
                        gArrival = gFinish;
                        finalIndex = i;
                    }
                    time = gArrival;
                }

                if (finalIndex == 0) 
                {
                    int tempIndex = 1;
                    finalLength = processorQueues[tempIndex].length();
                    for (int i = 1; i < processors+1; i++) 
                    {
                        length = processorQueues[i].length();
                        if (length < finalLength) 
                        {
                            finalLength = length;
                            tempIndex = i;
                        }
                    }

                    allJobs = (Job)storage.dequeue();
                    processorQueues[tempIndex].enqueue(allJobs);
                    if (processorQueues[tempIndex].length() == 1) 
                    {
                        allJobs = (Job)processorQueues[tempIndex].peek();
                        allJobs.computeFinishTime(time);
                    }
                }
                else 
                {
                    allJobs = (Job)processorQueues[finalIndex].dequeue();
                    int tempWait = allJobs.getWaitTime();
                    if (tempWait > maxWait)
                        maxWait = tempWait;
                    totalWait += tempWait;

                    if (processorQueues[finalIndex].length() >= 1) 
                    {
                        allJobs = (Job)processorQueues[finalIndex].peek();
                        allJobs.computeFinishTime(time);
                    }
                }

                trace.println();
                trace.println("time=" + time);
                trace.println("0: " + storage.toString());
                for(int i = 1; i < processors+1; i++)
                    trace.println(i + ": " + processorQueues[i]);
                time++;
            }

            avgWait = ((double)totalWait/m);
            avgWait = (double)Math.round(avgWait*100)/100;
            trace.println();
            if (processors == 1)
                report.println(processors + " processor: totalWait=" + totalWait + ", maxWait=" + maxWait + ", averageWait=" + avgWait);
            else
                report.println(processors + " processors: totalWait=" + totalWait + ", maxWait=" + maxWait + ", averageWait=" + avgWait);

            time = 0;
        }

        inScanner.close();
        report.close();
        trace.close();

    }

    
    /* Returns number of jobs needed to be completed*/
    /*
    public static int numOfJobs(Scanner sc) { 
        String s = sc.nextLine();
        int x = Integer.parseInt(s);
        return x;
    }
    */

    public static Job getJob(Scanner in) { /* Given in SimulationStub*/
        String[] s = in.nextLine().split(" ");
        int a = Integer.parseInt(s[0]);
        int d = Integer.parseInt(s[1]);
        return new Job(a, d);
    }
}
